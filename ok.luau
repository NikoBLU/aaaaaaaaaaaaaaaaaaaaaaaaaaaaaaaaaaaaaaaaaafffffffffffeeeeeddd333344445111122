local a,b,c,d,e={},{},{},require,game:GetService'HttpService'local f=function(f)return function()return e:JSONDecode(f)end end local g,h=function(g)local function h(i,j)local k,l=i[1],i[2]local m,n=k[1],k[2]local o=Instance.new(n and'ModuleScript'or'Folder')o.Parent=j o.Name=m if n then b[o]=n b[n]=o end for p,q in ipairs(l or{})do h(q,o)end return o end h(f(g)())end,function(g)if typeof(g)=='Instance'then g=b[g]or g end if typeof(g)~='string'then return d(g)end local h=a[g]if not h then return end local i=c[g]if i then return i end local j,k=pcall(h,b[g])if not j then error(k)return end c[g]=k return k end a['0']=function(i)local j=h(i.include.RuntimeLib)local k=j.import(i,i,'classes','logger')local l,m,n,o,p=k.default,k.LogType,j.import(i,i,'lib','functions').waitForGameLoad,j.import(i,i,'classes','messages').default,j.import(i,i,'lib','config')local q,r,s,t,u=p.default,p.Store,j.import(i,i,'classes','ai').default,j.import(i,i,'classes','antiafk').default,j.import(i,i,'classes','store').default l:log(m.Debug,'Script','Started execution')n()t()local v,w,x=false,(s.new())x=o(function(y)local z=y local A,B=z.message,z.sender if not(x and B)then return nil end if B['local']then local C=u:get(r.AIMessage)if C and y.tagged()then x:sendLocal('tags')end u:set(r.AIMessage)return nil end if v or not B.allowed()or y.tagged()then return nil end local C=q.Settings.MessageProcessDelay if C~=0 and C==C and C then task.spawn(function()v=true task.wait(C)v=false end)end l:log(m.Debug,'Message',`{B.name}: "{A}"`)w:createChatCompletion(x,y)end)l:log(m.Debug,'Script','Completed execution')return nil end a['1']=function(i)local j=h(i.Parent.Parent.include.RuntimeLib)local k,l=j.import(i,i.Parent,'store').default,j.import(i,i.Parent.Parent,'lib','config')local m,n=l.default,l.Store local o=function()local o=k:get(n.Instance)if not(o~=0 and o==o and o)then o=0 end return o end k:set(n.Instance,o()+1)local p,q={Print='print',Debug='debug',Error='error',}do q=setmetatable({},{__tostring=function()return'Log'end,})q.__index=q function q.new(...)local r=setmetatable({},q)return r:constructor(...)or r end function q.constructor(r,s,t,u,v)r._type=t r.title=u r.text=v r:log(s)end function q.getFunction(r)local s=r._type repeat if s==(p.Print)then return print end if s==(p.Debug)then if m.Script.Debug then return warn end break end if s==(p.Error)then return error end until true end function q.log(r,s)local t=r:getFunction()if not t then return nil end local u=`({s}) [{r.title}]: {r.text}`t(u)end end local r do r=setmetatable({},{__tostring=function()return'Logger'end,})r.__index=r function r.new(...)local s=setmetatable({},r)return s:constructor(...)or s end function r.constructor(s)s.instance=o()end function r.log(s,t,u,v)q.new(s.instance,t,u,v)end end local s=r.new()return{LogType=p,default=s,}end a['2']=function(i)local j,k={}do k=setmetatable({},{__tostring=function()return'Store'end,})k.__index=k function k.new(...)local l=setmetatable({},k)return l:constructor(...)or l end function k.constructor(l)l.store=function()return(getgenv and{(getgenv())}or{j})[1]end end function k.format(l,m)return`RobloxAI.{m}`end function k.get(l,m,n,o)local p=l.store()[l:format(m)]if p~=nil then return p end return(n~=0 and n==n and n~=''and n and{(o and{(l:set(m,n))}or{n})[1]}or{nil})[1]end function k.set(l,m,n)l.store()[l:format(m)]=n return n end end local l=k.new()return{default=l}end a['3']=function(i)local j=h(i.Parent.Parent.include.RuntimeLib)local k,l,m=j.import(i,i.Parent.Parent,'config').default,j.import(i,i.Parent.Parent,'classes','store').default,{Instance='Instance',AIMessage='AI.Message',AIMessages='AI.Messages',Messages='Messages',PlayersWalking='Players.Walking',AntiAFK='AntiAFK',Config='Config',}local n=l:get(m.Config,k,false)return{Store=m,default=n,}end a['4']=function(i)local j={Script={Name='RobloxAI',Whitelist={},Blacklist={},Debug=false,},Settings={AntiAFK=true,MinimumDistance=8,MessageProcessDelay=1,LookSpeed=0.25,},AI={Prompt='',Model='gpt-4o-mini',EnabledFunctions={'sendMessage','lookAtPlayer','teleportToPlayer','walkToPlayer','followPlayer','stopWalkingToPlayer','jump','setWalkSpeed','setJumpPower',},MaximumCharacterLimit=200,MaximumMessageContext=5,Api='https://api.openai.com/v1/chat/completions',Key='OPENAI_API_KEY',},}return{default=j}end a['5']=function(i)local j,k,l,m,n,o=h(i.Parent.Promise),game:GetService'RunService','roblox-ts: ','node_modules','@rbxts',{}o.Promise=j local p=function(p)return k:IsStudio()and p:FindFirstAncestorWhichIsA'Plugin'~=nil end function o.getModule(q,r,s)if s==nil then s=r r=n end if k:IsRunning()and k:IsClient()and not p(q)and not game:IsLoaded()then game.Loaded:Wait()end local t=q repeat local u=t:FindFirstChild(m)if u then local v=u:FindFirstChild(r)if v then local w=v:FindFirstChild(s)if w then return w end end end t=t.Parent until t==nil error(l..'Could not find module: '..s,2)end local q,r={},{}function o.import(s,t,...)for u=1,select('#',...)do t=t:WaitForChild((select(u,...)))end if t.ClassName~='ModuleScript'then error(l..'Failed to import! Expected ModuleScript, got '..t.ClassName,2)end q[s]=t local u,v=t,0 while u do v=v+1 u=q[u]if u==t then local w=u.Name for x=1,v do u=q[u]w=w..'  \u{21d2} '..u.Name end error(l..'Failed to import! Detected a circular dependency chain: '..w,2)end end if not r[t]then if _G[t]then error(l..[[Invalid module access! Do you have multiple TS runtimes trying to import this? ]]..t:GetFullName(),2)end _G[t]=o r[t]=true end local w=h(t)if q[s]==t then q[s]=nil end return w end function o.instanceof(s,t)if type(t)=='table'and type(t.instanceof)=='function'then return t.instanceof(s)end if type(s)=='table'then s=getmetatable(s)while s~=nil do if s==t then return true end local u=getmetatable(s)if u then s=u.__index else s=nil end end end return false end function o.async(s)return function(...)local t,u=select('#',...),{...}return j.new(function(v,w)coroutine.wrap(function()local x,y=pcall(s,unpack(u,1,t))if x then v(y)else w(y)end end)()end)end end function o.await(s)if not j.is(s)then return s end local t,u=s:awaitStatus()if t==j.Status.Resolved then return u elseif t==j.Status.Rejected then error(u,2)else error('The awaited Promise was cancelled',2)end end local s,t=2^31,2^32 local u=function(u)if bit32.btest(u,s)then return u-t else return u end end function o.bit_lrsh(v,w)return u(bit32.arshift(v,w))end o.TRY_RETURN=1 o.TRY_BREAK=2 o.TRY_CONTINUE=3 function o.try(v,w,x)local y,z,A=pcall(v)local B,C if y then B=z else C=z end local D,E=true if not y and w then local F,G D,F,G=pcall(w,C)local H if D then H=F else E=F end if H then B,A=H,G end end if x then local F,G=x()if F then B,A=F,G end end if B~=o.TRY_RETURN and B~=o.TRY_BREAK and B~=o.TRY_CONTINUE then if not D then error(E,2)end if not y and not w then error(C,2)end end return B,A end function o.generator(v)local w=coroutine.create(v)return{next=function(...)if coroutine.status(w)=='dead'then return{done=true}else local x,y=coroutine.resume(w,...)if x==false then error(y,2)end return{value=y,done=coroutine.status(w)=='dead',}end end,}end return o end a['7']=function(i)local j=h(i.Parent.Parent.include.RuntimeLib)local k=j.import(i,i.Parent.Parent,'classes','logger')local l,m=k.default,k.LogType local n,o,p=function()l:log(m.Debug,'Script','Waiting for game load')if not game:IsLoaded()then game.Loaded:Wait()end end,function(n,o)local p,q=n,#o return string.sub(p,1,q)==o end,function(n)return game:GetService(n)end return{waitForGameLoad=n,startsWith=o,getCustomService=p,}end a['6']=function(i)local j,k,l,m,n,o,p='Non-promise value passed into %s at index %s','Please pass a list of promises to %s','Please pass a handler function to %s!',{__mode='k',},function(j)if type(j)=='function'then return true end if type(j)=='table'then local k=getmetatable(j)if k and type(rawget(k,'__call'))=='function'then return true end end return false end,function(j,k)local l={}for m,n in ipairs(k)do l[n]=n end return setmetatable(l,{__index=function(m,n)error(string.format('%s is not in %s!',n,j),2)end,__newindex=function()error(string.format('Creating new members in %s is not allowed!',j),2)end,})end do p={Kind=o('Promise.Error.Kind',{'ExecutionError','AlreadyCancelled','NotResolvedInTime','TimedOut',}),}p.__index=p function p.new(q,r)q=q or{}return setmetatable({error=tostring(q.error)or'[This error has no error text.]',trace=q.trace,context=q.context,kind=q.kind,parent=r,createdTick=os.clock(),createdTrace=debug.traceback(),},p)end function p.is(q)if type(q)=='table'then local r=getmetatable(q)if type(r)=='table'then return rawget(q,'error')~=nil and type(rawget(r,'extend'))=='function'end end return false end function p.isKind(q,r)assert(r~=nil,'Argument #2 to Promise.Error.isKind must not be nil')return p.is(q)and q.kind==r end function p.extend(q,r)r=r or{}r.kind=r.kind or q.kind return p.new(r,q)end function p.getErrorChain(q)local r={q}while r[#r].parent do table.insert(r,r[#r].parent)end return r end function p.__tostring(q)local r={string.format('-- Promise.Error(%s) --',q.kind or'?'),}for s,t in ipairs(q:getErrorChain())do table.insert(r,table.concat({t.trace or t.error,t.context,},'\n'))end return table.concat(r,'\n')end end local q,r,s=function(...)return select('#',...),{...}end,function(q,...)return q,select('#',...),{...}end,function(q)assert(q~=nil,'traceback is nil')return function(r)if type(r)=='table'then return r end return p.new{error=r,kind=p.Kind.ExecutionError,trace=debug.traceback(tostring(r),2),context='Promise created at:\n\n'..q,}end end local t=function(t,u,...)return r(xpcall(u,s(t),...))end local u,v,w=function(u,v,w,x)return function(...)local y,z,A=t(u,v,...)if y then w(unpack(A,1,z))else x(A[1])end end end,function(u)return next(u)==nil end,{Error=p,Status=o('Promise.Status',{'Started','Resolved','Rejected','Cancelled',}),_getTime=os.clock,_timeEvent=game:GetService'RunService'.Heartbeat,_unhandledRejectionCallbacks={},}w.prototype={}w.__index=w.prototype function w._new(x,y,z)if z~=nil and not w.is(z)then error('Argument #2 to Promise.new must be a promise or nil',2)end local A={_thread=nil,_source=x,_status=w.Status.Started,_values=nil,_valuesLength=-1,_unhandledRejection=true,_queuedResolve={},_queuedReject={},_queuedFinally={},_cancellationHook=nil,_parent=z,_consumers=setmetatable({},m),}if z and z._status==w.Status.Started then z._consumers[A]=true end setmetatable(A,w)local B,C,D=function(...)A:_resolve(...)end,function(...)A:_reject(...)end,function(B)if B then if A._status==w.Status.Cancelled then B()else A._cancellationHook=B end end return A._status==w.Status.Cancelled end A._thread=coroutine.create(function()local E, F, G=t(A._source,y,B,C,D)if not E then C(G[1])end end)task.spawn(A._thread)return A end function w.new(x)return w._new(debug.traceback(nil,2),x)end function w.__tostring(x)return string.format('Promise(%s)',x._status)end function w.defer(x)local y,z=(debug.traceback(nil,2))z=w._new(y,function(A,B,C)local D D=w._timeEvent:Connect(function()D:Disconnect()local E, F, G=t(y,x,A,B,C)if not E then B(G[1])end end)end)return z end w.async=w.defer function w.resolve(...)local x,y=q(...)return w._new(debug.traceback(nil,2),function(z)z(unpack(y,1,x))end)end function w.reject(...)local x,y=q(...)return w._new(debug.traceback(nil,2),function(z,A)A(unpack(y,1,x))end)end function w._try(x,y,...)local z,A=q(...)return w._new(x,function(B)B(y(unpack(A,1,z)))end)end function w.try(x,...)return w._try(debug.traceback(nil,2),x,...)end function w._all(x,y,z)if type(y)~='table'then error(string.format(k,'Promise.all'),3)end for A,B in pairs(y)do if not w.is(B)then error(string.format(j,'Promise.all',tostring(A)),3)end end if#y==0 or z==0 then return w.resolve{}end return w._new(x,function(A,B,C)local D,E,F,G,H={},{},0,0,false local I=function()for I,J in ipairs(E)do J:cancel()end end local J=function(J,...)if H then return end F=F+1 if z==nil then D[J]=...else D[F]=...end if F>=(z or#y)then H=true A(D)I()end end C(I)for K,L in ipairs(y)do E[K]=L:andThen(function(...)J(K,...)end,function(...)G=G+1 if z==nil or#y-G<z then I()H=true B(...)end end)end if H then I()end end)end function w.all(x)return w._all(debug.traceback(nil,2),x)end function w.fold(x,y,z)assert(type(x)=='table','Bad argument #1 to Promise.fold: must be a table')assert(n(y),'Bad argument #2 to Promise.fold: must be a function')local A=w.resolve(z)return w.each(x,function(B,C)A=A:andThen(function(D)return y(D,B,C)end)end):andThen(function()return A end)end function w.some(x,y)assert(type(y)=='number','Bad argument #2 to Promise.some: must be a number')return w._all(debug.traceback(nil,2),x,y)end function w.any(x)return w._all(debug.traceback(nil,2),x,1):andThen(function(y)return y[1]end)end function w.allSettled(x)if type(x)~='table'then error(string.format(k,'Promise.allSettled'),2)end for y,z in pairs(x)do if not w.is(z)then error(string.format(j,'Promise.allSettled',tostring(y)),2)end end if#x==0 then return w.resolve{}end return w._new(debug.traceback(nil,2),function(y,z,A)local B,C,D={},{},0 local E=function(E,...)D=D+1 B[E]=...if D>=#x then y(B)end end A(function()for F,G in ipairs(C)do G:cancel()end end)for F,G in ipairs(x)do C[F]=G:finally(function(...)E(F,...)end)end end)end function w.race(x)assert(type(x)=='table',string.format(k,'Promise.race'))for y,z in pairs(x)do assert(w.is(z),string.format(j,'Promise.race',tostring(y)))end return w._new(debug.traceback(nil,2),function(y,z,A)local B,C={},false local D=function()for D,E in ipairs(B)do E:cancel()end end local E=function(E)return function(...)D()C=true return E(...)end end if A(E(z))then return end for F,G in ipairs(x)do B[F]=G:andThen(E(y),E(z))end if C then D()end end)end function w.each(x,y)assert(type(x)=='table',string.format(k,'Promise.each'))assert(n(y),string.format(l,'Promise.each'))return w._new(debug.traceback(nil,2),function(z,A,B)local C,D,E={},{},false local F=function()for F,G in ipairs(D)do G:cancel()end end B(function()E=true F()end)local G={}for H,I in ipairs(x)do if w.is(I)then if I:getStatus()==w.Status.Cancelled then F()return A(p.new{error='Promise is cancelled',kind=p.Kind.AlreadyCancelled,context=string.format([[The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.  That Promise was created at:  %s]],H,I._source),})elseif I:getStatus()==w.Status.Rejected then F()return A(select(2,I:await()))end local J=I:andThen(function(...)return...end)table.insert(D,J)G[H]=J else G[H]=I end end for H,I in ipairs(G)do if w.is(I)then local J J,I=I:await()if not J then F()return A(I)end end if E then return end local J=w.resolve(y(I,H))table.insert(D,J)local K,L=J:await()if not K then F()return A(L)end C[H]=L end z(C)end)end function w.is(x)if type(x)~='table'then return false end local y=getmetatable(x)if y==w then return true elseif y==nil then return n(x.andThen)elseif type(y)=='table'and type(rawget(y,'__index'))=='table'and n(rawget(rawget(y,'__index'),'andThen'))then return true end return false end function w.promisify(x)return function(...)return w._try(debug.traceback(nil,2),x,...)end end do local x,y function w.delay(z)assert(type(z)=='number','Bad argument #1 to Promise.delay, must be a number.')if not(z>=1/60)or z==math.huge then z=1/60 end return w._new(debug.traceback(nil,2),function(A,B,C)local D=w._getTime()local E=D+z local F={resolve=A,startTime=D,endTime=E,}if y==nil then x=F y=w._timeEvent:Connect(function()local G=w._getTime()while x~=nil and x.endTime<G do local H=x x=H.next if x==nil then y:Disconnect()y=nil else x.previous=nil end H.resolve(w._getTime()-H.startTime)end end)else if x.endTime<E then local G=x local H=G.next while H~=nil and H.endTime<E do G=H H=G.next end G.next=F F.previous=G if H~=nil then F.next=H H.previous=F end else F.next=x x.previous=F x=F end end C(function()local G=F.next if x==F then if G==nil then y:Disconnect()y=nil else G.previous=nil end x=G else local H=F.previous H.next=G if G~=nil then G.previous=H end end end)end)end end function w.prototype.timeout(x,y,z)local A=debug.traceback(nil,2)return w.race{w.delay(y):andThen(function()return w.reject(z==nil and p.new{kind=p.Kind.TimedOut,error='Timed out',context=string.format('Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s',y,A),}or z)end),x,}end function w.prototype.getStatus(x)return x._status end function w.prototype._andThen(x,y,z,A)x._unhandledRejection=false if x._status==w.Status.Cancelled then local B=w.new(function()end)B:cancel()return B end return w._new(y,function(B,C,D)local E=B if z then E=u(y,z,B,C)end local F=C if A then F=u(y,A,B,C)end if x._status==w.Status.Started then table.insert(x._queuedResolve,E)table.insert(x._queuedReject,F)D(function()if x._status==w.Status.Started then table.remove(x._queuedResolve,table.find(x._queuedResolve,E))table.remove(x._queuedReject,table.find(x._queuedReject,F))end end)elseif x._status==w.Status.Resolved then E(unpack(x._values,1,x._valuesLength))elseif x._status==w.Status.Rejected then F(unpack(x._values,1,x._valuesLength))end end,x)end function w.prototype.andThen(x,y,z)assert(y==nil or n(y),string.format(l,'Promise:andThen'))assert(z==nil or n(z),string.format(l,'Promise:andThen'))return x:_andThen(debug.traceback(nil,2),y,z)end function w.prototype.catch(x,y)assert(y==nil or n(y),string.format(l,'Promise:catch'))return x:_andThen(debug.traceback(nil,2),nil,y)end function w.prototype.tap(x,y)assert(n(y),string.format(l,'Promise:tap'))return x:_andThen(debug.traceback(nil,2),function(...)local z=y(...)if w.is(z)then local A,B=q(...)return z:andThen(function()return unpack(B,1,A)end)end return...end)end function w.prototype.andThenCall(x,y,...)assert(n(y),string.format(l,'Promise:andThenCall'))local z,A=q(...)return x:_andThen(debug.traceback(nil,2),function()return y(unpack(A,1,z))end)end function w.prototype.andThenReturn(x,...)local y,z=q(...)return x:_andThen(debug.traceback(nil,2),function()return unpack(z,1,y)end)end function w.prototype.cancel(x)if x._status~=w.Status.Started then return end x._status=w.Status.Cancelled if x._cancellationHook then x._cancellationHook()end coroutine.close(x._thread)if x._parent then x._parent:_consumerCancelled(x)end for y in pairs(x._consumers)do y:cancel()end x:_finalize()end function w.prototype._consumerCancelled(x,y)if x._status~=w.Status.Started then return end x._consumers[y]=nil if next(x._consumers)==nil then x:cancel()end end function w.prototype._finally(x,y,z)x._unhandledRejection=false local A=w._new(y,function(A,B,C)local D C(function()x:_consumerCancelled(x)if D then D:cancel()end end)local E=A if z then E=function(...)local F=z(...)if w.is(F)then D=F F:finally(function(G)if G~=w.Status.Rejected then A(x)end end):catch(function(...)B(...)end)else A(x)end end end if x._status==w.Status.Started then table.insert(x._queuedFinally,E)else E(x._status)end end)return A end function w.prototype.finally(x,y)assert(y==nil or n(y),string.format(l,'Promise:finally'))return x:_finally(debug.traceback(nil,2),y)end function w.prototype.finallyCall(x,y,...)assert(n(y),string.format(l,'Promise:finallyCall'))local z,A=q(...)return x:_finally(debug.traceback(nil,2),function()return y(unpack(A,1,z))end)end function w.prototype.finallyReturn(x,...)local y,z=q(...)return x:_finally(debug.traceback(nil,2),function()return unpack(z,1,y)end)end function w.prototype.awaitStatus(x)x._unhandledRejection=false if x._status==w.Status.Started then local y=coroutine.running()x:finally(function()task.spawn(y)end):catch(function()end)coroutine.yield()end if x._status==w.Status.Resolved then return x._status,unpack(x._values,1,x._valuesLength)elseif x._status==w.Status.Rejected then return x._status,unpack(x._values,1,x._valuesLength)end return x._status end local x=function(x,...)return x==w.Status.Resolved,...end function w.prototype.await(y)return x(y:awaitStatus())end local y=function(y,...)if y~=w.Status.Resolved then error((...)==nil and'Expected Promise rejected with no value.'or(...),3)end return...end function w.prototype.expect(z)return y(z:awaitStatus())end w.prototype.awaitValue=w.prototype.expect function w.prototype._unwrap(z)if z._status==w.Status.Started then error('Promise has not resolved or rejected.',2)end local A=z._status==w.Status.Resolved return A,unpack(z._values,1,z._valuesLength)end function w.prototype._resolve(z,...)if z._status~=w.Status.Started then if w.is((...))then(...):_consumerCancelled(z)end return end if w.is((...))then if select('#',...)>1 then local A=string.format('When returning a Promise from andThen, extra arguments are '..'discarded! See:\n\n%s',z._source)warn(A)end local A=...local B=A:andThen(function(...)z:_resolve(...)end,function(...)local B=A._values[1]if A._error then B=p.new{error=A._error,kind=p.Kind.ExecutionError,context=[=[[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]]=],}end if p.isKind(B,p.Kind.ExecutionError)then return z:_reject(B:extend{error='This Promise was chained to a Promise that errored.',trace='',context=string.format([[The Promise at:  %s ...Rejected because it was chained to the following Promise, which encountered an error: ]],z._source),})end z:_reject(...)end)if B._status==w.Status.Cancelled then z:cancel()elseif B._status==w.Status.Started then z._parent=B B._consumers[z]=true end return end z._status=w.Status.Resolved z._valuesLength,z._values=q(...)for A,B in ipairs(z._queuedResolve)do coroutine.wrap(B)(...)end z:_finalize()end function w.prototype._reject(z,...)if z._status~=w.Status.Started then return end z._status=w.Status.Rejected z._valuesLength,z._values=q(...)if not v(z._queuedReject)then for A,B in ipairs(z._queuedReject)do coroutine.wrap(B)(...)end else local A=tostring((...))coroutine.wrap(function()w._timeEvent:Wait()if not z._unhandledRejection then return end local B=string.format('Unhandled Promise rejection:\n\n%s\n\n%s',A,z._source)for C,D in ipairs(w._unhandledRejectionCallbacks)do task.spawn(D,z,unpack(z._values,1,z._valuesLength))end if w.TEST then return end warn(B)end)()end z:_finalize()end function w.prototype._finalize(z)for A,B in ipairs(z._queuedFinally)do coroutine.wrap(B)(z._status)end z._queuedFinally=nil z._queuedReject=nil z._queuedResolve=nil if not w.TEST then z._parent=nil z._consumers=nil end task.defer(coroutine.close,z._thread)end function w.prototype.now(z,A)local B=debug.traceback(nil,2)if z._status==w.Status.Resolved then return z:_andThen(B,function(...)return...end)else return w.reject(A==nil and p.new{kind=p.Kind.NotResolvedInTime,error='This Promise was not resolved in time for :now()',context=':now() was called at:\n\n'..B,}or A)end end function w.retry(z,A,...)assert(n(z),'Parameter #1 to Promise.retry must be a function')assert(type(A)=='number','Parameter #2 to Promise.retry must be a number')local B,C={...},select('#',...)return w.resolve(z(...)):catch(function(...)if A>0 then return w.retry(z,A-1,unpack(B,1,C))else return w.reject(...)end end)end function w.retryWithDelay(z,A,B,...)assert(n(z),'Parameter #1 to Promise.retry must be a function')assert(type(A)=='number','Parameter #2 (times) to Promise.retry must be a number')assert(type(B)=='number','Parameter #3 (seconds) to Promise.retry must be a number')local C,D={...},select('#',...)return w.resolve(z(...)):catch(function(...)if A>0 then w.delay(B):await()return w.retryWithDelay(z,A-1,B,unpack(C,1,D))else return w.reject(...)end end)end function w.fromEvent(z,A)A=A or function()return true end return w._new(debug.traceback(nil,2),function(B,C,D)local E,F=false local G=function()F:Disconnect()F=nil end F=z:Connect(function(...)local H=A(...)if H==true then B(...)if F then G()else E=true end elseif type(H)~='boolean'then error'Promise.fromEvent predicate should always return a boolean'end end)if E and F then return G()end D(G)end)end function w.onUnhandledRejection(z)table.insert(w._unhandledRejectionCallbacks,z)return function()local A=table.find(w._unhandledRejectionCallbacks,z)if A then table.remove(w._unhandledRejectionCallbacks,A)end end end return w end a['8']=function(i)local j=h(i.Parent.Parent.include.RuntimeLib)local k,l,m,n,o=j.import(i,i.Parent,'players').default,j.import(i,i.Parent.Parent,'lib','config').Store,j.import(i,i.Parent,'connection').Connection,game:GetService'TextChatService',game:GetService'ReplicatedStorage'local p,q=k:localPlayer(),function()return n.ChatVersion==Enum.ChatVersion.TextChatService end local r=function()if q()then local r=n:FindFirstChild'TextChannels'if r~=nil then r=r:FindFirstChild'RBXGeneral'end local s=r local t=s if t~=nil then t=t:IsA'TextChannel'end if t then return s end end local r=o:FindFirstChild'DefaultChatSystemChatEvents'if r~=nil then r=r:FindFirstChild'SayMessageRequest'end local s=r local t=s if t~=nil then t=t:IsA'RemoteEvent'end if t then return s end end local s,t=function(s)local t,u=s.message,r()local v=u if v~=nil then v=v:IsA'TextChannel'end if v then u:SendAsync(t)else local w=u if w~=nil then w=w:IsA'RemoteEvent'end if w then u:FireServer(t,'All')end end end do t=setmetatable({},{__tostring=function()return'Message'end,})t.__index=t function t.new(...)local u=setmetatable({},t)return u:constructor(...)or u end function t.constructor(u,v,w,x,y)u.tagged=function()local z={string.match(u.message,'^#+$'),}if z~=nil then z=#z==0 end return not z end local z=v if type(z)=='string'then u.message=v u.sender=w u.whisper=x u.channel=y elseif v.Name~=nil then u.message=v.Text local A,B=u,v.TextSource if B~=nil then B=B.UserId end u.sender=A:getSender(B)u.channel=v.TextChannel u.whisper=u:getWhisper(u.channel)else u.message=v.Message u.sender=k:fromName(v.FromSpeaker)u.whisper=u:getWhisper(v)end end function t.getSender(u,v)local w=v if w~=0 and w==w and w then w=k:fromID(v)end local x=w if not(x~=0 and x==x and x)then x=nil end return x end function t.getWhisper(u,v)if not v then return false end local w if v.Name~=nil then local x=v if x~=nil then x=x.Name if x~=nil then x=table.remove(string.split(string.lower(x),':'),1)end end w=x=='rbxwhisper'else w=string.lower(v.MessageType)=='whisper'end return w end function t.respond(u,v,w)local x,y=v.message,v.sender local z=w or y if u.channel then u.channel:SendAsync(x)elseif z and not q()then s{message=`/whisper {z.name} {x}`,}end end end local u do local v=m u=setmetatable({},{__tostring=function()return'Messages'end,__index=v,})u.__index=u function u.new(...)local w=setmetatable({},u)return w:constructor(...)or w end function u.constructor(w,...)v.constructor(w,...)end function u.send(w,x,y)local z=x if type(z)=='string'then s{message=x}elseif x.whisper then x:respond(x,y)else s(x)end end function u.sendLocal(w,x,y)local z,A,B=x.whisper,x.channel,x.sender w:send(t.new(y,p,z,A),B)end end local v=function()if q()then return n.MessageReceived end local v=o:FindFirstChild'DefaultChatSystemChatEvents'if v~=nil then v=v:FindFirstChild'OnMessageDoneFiltering'end local w=v local x=w if x~=nil then x=x:IsA'RemoteEvent'end if x then return w.OnClientEvent end end local w=function(w)local x,y=v(),function(x)return w(t.new(x))end return x and u.new{key=l.Messages,signal=x,callback=y,}end return{default=w,Message=t,Messages=u,}end a['9']=function(i)local j=h(i.Parent.Parent.include.RuntimeLib)local k=j.import(i,i.Parent.Parent,'lib','config')local l,m,n,o,p,q=k.default,k.Store,j.import(i,i.Parent.Parent,'lib','functions').startsWith,j.import(i,i.Parent,'store').default,game:GetService'TweenService',game:GetService'Players'local r,s,t=(q.LocalPlayer)do t=setmetatable({},{__tostring=function()return'ExtendedPlayer'end,})t.__index=t function t.new(...)local u=setmetatable({},t)return u:constructor(...)or u end function t.constructor(u,v)u.humanoid=function()local w=u.player.Character if w~=nil then w=w:FindFirstChildOfClass'Humanoid'end return w end u.rootPart=function()local w=u.humanoid()if w~=nil then w=w.RootPart end return w end u.inAir=function()local w=u.humanoid()if w~=nil then w=w:GetState()end return w==Enum.HumanoidStateType.Freefall end u.allowed=function()return u.whitelisted and u:inDistance()end u.player=v u.id=v.UserId u.name=v.Name u.displayName=v.DisplayName u.whitelisted=u:_whitelisted()and not u:blacklisted()u['local']=u:self()end function t._whitelisted(u)local v=l.Script.Whitelist local w=#v==0 if not w then local x=u.name w=table.find(v,x)~=nil end return w end function t.blacklisted(u)local v,w=l.Script.Blacklist,u.name return table.find(v,w)~=nil end function t.self(u)return u.player==r end function t.onIdled(u,v)return u.player.Idled:Connect(v)end function t.matches(u,v)local w,x=string.lower(u.name),string.lower(u.displayName)local y,z={w,x},v local A=table.find(y,z)~=nil if not A then A=n(w,v)or n(x,v)end return A end function t.localPlayer(u)return s.new(r)end function t.distanceFrom(u,v)return u.player:DistanceFromCharacter(v)end function t.distance(u)if u['local']then return nil end local v=u:localPlayer().rootPart()if v then return u:distanceFrom(v.Position)end end function t.inDistance(u)local v=l.Settings.MinimumDistance if v~=0 and v==v and v then v=u.rootPart()end if not(v~=0 and v==v and v)then return true end local w=u:localPlayer().rootPart()if w~=nil then w=w.Position end local x=w return(x and{(u:distanceFrom(x)<=l.Settings.MinimumDistance)}or{false})[1]end function t.teleportTo(u)if u['local']then return nil end local v=u:localPlayer()local w,x=v.rootPart(),u.rootPart()if not(w and x)then return nil end v:sit(false)task.wait()w.CFrame=x.CFrame end function t.walkTo(u)local v=u:localPlayer()local w,x=v.humanoid(),u.rootPart()if not(w and x)then return nil end v:sit(false)task.wait()w:MoveTo(x.Position)if u.inAir()then v:jump()end end function t.lookAt(u,v)local w,x=u:localPlayer().rootPart(),u.rootPart()if not(w and x)then return nil end local y,z=Vector3.new(x.Position.X,w.Position.Y,x.Position.Z),l.Settings.LookSpeed if not(z~=0 and z==z and z)then z=0.25 end local A=TweenInfo.new(z,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)local B=p:Create(w,A,{CFrame=CFrame.lookAt(w.Position,y),})B:Play()if v then B.Completed:Wait()end end end do local u=t s=setmetatable({},{__tostring=function()return'ExtendedLocalPlayer'end,__index=u,})s.__index=s function s.new(...)local v=setmetatable({},s)return v:constructor(...)or v end function s.constructor(v,...)u.constructor(v,...)end function s.jump(v)local w=v.humanoid()if w and not v.inAir()then w:ChangeState(Enum.HumanoidStateType.Jumping)return true end return false end function s.sit(v,w)if w==nil then w=true end local x=v.humanoid()if x then x.Sit=w end end function s.setWalk(v,w)local x=v.humanoid()if x then x.WalkSpeed=w end end function s.setJump(v,w)local x=v.humanoid()if x then x.JumpPower=w end end end local u do u=setmetatable({},{__tostring=function()return'ExtendedPlayers'end,})u.__index=u function u.new(...)local v=setmetatable({},u)return v:constructor(...)or v end function u.constructor(v)end function u.get(v)local w=q:GetPlayers()local x,y=table.create(#w),function(x)return((x==r and{s}or{t})[1]).new(x)end for z,A in w do x[z]=y(A,z-1,w)end return x end function u.localPlayer(v)return s.new(r)end function u.has(v,w)return v:fromID(w.id)~=nil end function u.fromID(v,w)local x,y,z=v:get(),function(x)return x.id==w end for A,B in x do if y(B,A-1,x)==true then z=B break end end return z end function u.fromName(v,w)local x,y,z=v:get(),function(x)return x.name==w end for A,B in x do if y(B,A-1,x)==true then z=B break end end return z end function u.fromPartial(v,w)w=string.lower(w)local x,y,z,A=v:get(),{},function(x)return not x['local']end,0 for B,C in x do if z(C,B-1,x)==true then A+=1 y[A]=C end end local B,C=function(B)return B:matches(w)end for D,E in y do if B(E,D-1,y)==true then C=E break end end return C end function u.walkTo(v,w,x)if w['local']then return nil end v:stopWalking()o:set(m.PlayersWalking,true)while true do local y=task.wait()if not(y~=0 and y==y and y)then break end local z=o:get(m.PlayersWalking)if z~=0 and z==z and z~=''and z then z=v:has(w)end if not(z~=0 and z==z and z~=''and z)then break end local A=w:distance()local B=A if B~=0 and B==B and B then B=A<=4 end local C=B if C~=0 and C==C and C then v:stopWalking(not x)else w:walkTo()end end end function u.stopWalking(v,w)if w==nil then w=true end if w then o:set(m.PlayersWalking,false)end v:localPlayer():walkTo()end end local v=u.new()return{ExtendedPlayer=t,ExtendedLocalPlayer=s,default=v,}end a['10']=function(i)local j=h(i.Parent.Parent.include.RuntimeLib)local k=j.import(i,i.Parent,'logger')local l,m,n,o=k.default,k.LogType,(j.import(i,i.Parent,'store').default)do o=setmetatable({},{__tostring=function()return'Connection'end,})o.__index=o function o.new(...)local p=setmetatable({},o)return p:constructor(...)or p end function o.constructor(p,q)p.options=q p:disconnect()p:connect()end function o.get(p)return n:get(p.options.key)or p.connection end function o.set(p,q)p.connection=q n:set(p.options.key,q)end function o.connect(p)local q=p.options local r,s,t,u=q.key,q.signal,q.callback,q.check if type(u)=='boolean'and not u then return nil end local v=(typeof(s)=='RBXScriptSignal'and{(s:Connect(t))}or{(s(t))})[1]p:set(v)if p.connection then l:log(m.Debug,r,'Connected')else l:log(m.Error,r,'Failed to connect')end end function o.disconnect(p)local q=p:get()local r=q if r~=nil then r=r.Connected end if r then q:Disconnect()l:log(m.Debug,p.options.key,'Disconnected')end p:set()end end return{Connection=o}end a['11']=function(i)local j=h(i.Parent.Parent.include.RuntimeLib)local k=j.import(i,i.Parent.Parent,'lib','config')local l,m,n,o=k.default,k.Store,j.import(i,i.Parent,'http').default,j.import(i,i.Parent,'logger')local p,q,r,s=o.default,o.LogType,j.import(i,i.Parent,'store').default,j.import(i,i,'functions')local t,u,v=s.default,(s.aiSendMessage)do v=setmetatable({},{__tostring=function()return'AI'end,})v.__index=v function v.new(...)local w=setmetatable({},v)return w:constructor(...)or w end function v.constructor(w)w.systemMessages={{role='system',content=`You are {l.Script.Name}, a Roblox player. Do not use markdown, send plain text. Be concise. Don't regurgitate useless information.`,},}w.messages=r:get(m.AIMessages,{})or{}w.functions=t local x,y=table.create(#t),function(x)return x.tool end for z,A in t do x[z]=y(A,z-1,t)end w.tools=x local z=l.AI.MaximumCharacterLimit if z~=0 and z==z and z then local A,B=w.systemMessages,{role='system',content=`Ensure your messages are not greater than {l.AI.MaximumCharacterLimit} characters.`,}table.insert(A,B)end if l.AI.Prompt~=''then local A,B=w.systemMessages,{role='system',content=l.AI.Prompt,}table.insert(A,B)end end function v.getFunction(w,x)local y,z,A=w.functions,function(y)return y.tool['function'].name==x end for B,C in y do if z(C,B-1,y)==true then A=C break end end return A end function v.addMessage(w,x)local y,z=w.messages,x table.insert(y,z)while true do local A=l.AI.MaximumMessageContext if A~=0 and A==A and A then A=#w.messages>l.AI.MaximumMessageContext end if not(A~=0 and A==A and A)then break end table.remove(w.messages,1)end r:set(m.AIMessages,w.messages)end function v.failedChatCompletion(w,x,y)u(x,y,'whoops')end function v.parseFunctionArguments(w,x)local y,z=j.try(function()return j.TRY_RETURN,{n:decodeJSON(x.arguments),}end,function()p:log(q.Error,'AI',`Failed to parse arguments for {x.name}`)end)if y then return unpack(z)end end function v.createChatCompletion(w,x,y)local z=y local A,B=z.message,z.sender if not B then return nil end local C={role='user',content=`{B.name}: {A}`,name=B.name,}w:addMessage(C)local D,E,F={model=l.AI.Model,},'messages',{}local G,H=#F,w.systemMessages local I=#H table.move(H,1,I,G+1,F)G+=I local J=w.messages table.move(J,1,#J,G+1,F)D[E]=F for K,L in(not(#w.tools==0)and{tools=w.tools,parallel_tool_calls=true,}or{})do D[K]=L end local K=D p:log(q.Debug,'AI','Sent request')local L=n:request(l.AI.Api,'POST',{{Name='Content-Type',Value='application/json',},{Name='Authorization',Value=`Bearer {l.AI.Key}`,},},K)if not L or L.Success==false then w:failedChatCompletion(x,y)p:log(q.Error,'AI','Request not successful')if L then p:log(q.Error,'AI',L.Body)end return nil end local M,N=j.try(function()L=n:decodeJSON(L.Body)end,function()w:failedChatCompletion(x,y)p:log(q.Error,'AI','Failed to parse response')return j.TRY_RETURN,{}end)if M then return unpack(N)end local O=L if O~=nil then O=O.choices if O~=nil then O=table.remove(O,1)if O~=nil then O=O.message end end end local P=O if not P then w:failedChatCompletion(x,y)p:log(q.Error,'AI','No response message')return nil end local Q=P if Q~=nil then Q=Q.tool_calls if Q~=nil then Q=#Q==0 end end B:lookAt(not Q)local R=P.content if R~=''and R then w:addMessage(P)local S,T=(l.AI.MaximumCharacterLimit)if S~=0 and S==S and S then local U=P if U~=nil then U=U.content if U~=nil then local V=l.AI.MaximumCharacterLimit U=string.sub(U,0,V)end end T=U else local U=P if U~=nil then U=U.content end T=U end local U=T u(x,y,U)p:log(q.Debug,'AI',U)end for S,T in P.tool_calls or{}do local U=T['function'].name local V=w:getFunction(U)if V then local W=w:parseFunctionArguments(T['function'])if W~=0 and W==W and W~=''and W then w:addMessage{role='assistant',content=`used {U}.`,}p:log(q.Debug,'AI',`{U}, {n:encodeJSON(W)}`)task.spawn(function()V.callback(W,x,y)end)end end end end end local w=v return{default=w}end a['12']=function(i)local j=h(i.Parent.Parent.include.RuntimeLib)local k=j.import(i,i.Parent,'logger')local l,m,n,o=k.default,k.LogType,(game:GetService'HttpService')do o=setmetatable({},{__tostring=function()return'HTTP'end,})o.__index=o function o.new(...)local p=setmetatable({},o)return p:constructor(...)or p end function o.constructor(p)p.library=request or n.RequestAsync end function o.encodeJSON(p,q)local r,s=j.try(function()return j.TRY_RETURN,{n:JSONEncode(q),}end,function()return j.TRY_RETURN,{'',}end)if r then return unpack(s)end end function o.decodeJSON(p,q)local r,s=j.try(function()return j.TRY_RETURN,{n:JSONDecode(q),}end,function()return j.TRY_RETURN,{nil}end)if r then return unpack(s)end end function o.request(p,q,r,s,t)if not p.library then l:log(m.Error,'Request','Request function unavailable.')return nil end local u,v,w,x={Url=q,Method=r,},'Headers',{},function(u,v)local w,x=v.Name,v.Value u[w]=x return u end for y=1,#s do w=x(w,s[y],y-1,s)end u[v]=w local y,z='Body',t u[y]=(type(z)=='string'and{t}or{(p:encodeJSON(t))})[1]u.Compress=Enum.HttpCompression.Gzip local A=u local B,C=j.try(function()local B=p.library(A)local C,D=B.Success,B.Body return j.TRY_RETURN,{{Success=C,Body=D,},}end,function()l:log(m.Error,'Request','Failed to create request.')end)if B then return unpack(C)end end end local p=o.new()return{default=p}end a['13']=function(i)local j=h(i.Parent.Parent.Parent.include.RuntimeLib)local k=j.import(i,i.Parent.Parent.Parent,'lib','config')local l,m,n,o=k.default,k.Store,j.import(i,i.Parent.Parent,'players').default,j.import(i,i.Parent.Parent,'store').default local p,q=n:localPlayer(),function(p,q,r)if not(p and q)then return nil end o:set(m.AIMessage,q)p:sendLocal(q,r)end local r,s,t,u={{tool={type='function',['function']={name='sendMessage',description=[[Sends a message into the Roblox chat. Use this in conjunction with other functions, to provide the user confirmation.]],parameters={type='object',properties={message={type='string',description='The message to send.',},amount={type='number',description='Amount of times to send the message. Set to 1 by default.',},interval={type='number',description=[[Amount of seconds in-between sending the messages. Set to 0 by default, and 0.25 by default if amount more than 1.]],},},required={'message','amount','interval',},additionalProperties=false,},strict=true,},},callback=function(r,s,t)local u,v=r.message,r.amount if v==nil then v=1 end local w=r.interval if w==nil then w=0 end do local x,y=0,false while true do if y then x+=1 else y=true end if not(x<v)then break end q(s,t,u)task.wait(w)end end end,},{tool={type='function',['function']={name='lookAtPlayer',description=[[Looks at a player. Never use this, unless the user explicitly asks for it.]],parameters={type='object',properties={player={type='string',description='The name of the player to look at.',},},required={'player',},additionalProperties=false,},strict=true,},},callback=function(r)local s=r.player local t=n:fromPartial(s)if t~=nil then t:lookAt()end end,},{tool={type='function',['function']={name='teleportToPlayer',description=[[Teleports to a player, instantly. Only use when user explicitly mentions word 'teleport'.]],parameters={type='object',properties={player={type='string',description='The name of the player to teleport to.',},},required={'player',},additionalProperties=false,},strict=true,},},callback=function(r)local s=r.player local t=n:fromPartial(s)if t~=nil then t:teleportTo()end end,},{tool={type='function',['function']={name='walkToPlayer',description='Walks to a player.',parameters={type='object',properties={player={type='string',description='The name of the player to walk to.',},},required={'player',},additionalProperties=false,},strict=true,},},callback=function(r)local s=r.player local t=n:fromPartial(s)if t then n:walkTo(t)end end,},{tool={type='function',['function']={name='followPlayer',description='Follow a player indefinitely.',parameters={type='object',properties={player={type='string',description='The name of the player to follow.',},},required={'player',},additionalProperties=false,},strict=true,},},callback=function(r)local s=r.player local t=n:fromPartial(s)if t then n:walkTo(t,true)end end,},{tool={type='function',['function']={name='stopWalkingToPlayer',description=[[Stops walking to, or following, a player - also known as 'unfollowing'.]],},},callback=function()n:stopWalking()end,},{tool={type='function',['function']={name='jump',description='Perform a jump.',parameters={type='object',properties={amount={type='number',description='Amount of times to jump. Set to 1 by default.',},interval={type='number',description=[[Amount of seconds in-between jumping. Set to 0 by default, and 1 by default if amount more than 1.]],},},required={'amount','interval',},additionalProperties=false,},strict=true,},},callback=function(r)local s=r.amount if s==nil then s=1 end local t=r.interval if t==nil then t=0 end do local u,v=0,false while true do if v then u+=1 else v=true end if not(u<s)then break end if p:jump()then task.wait(t)end end end end,},{tool={type='function',['function']={name='setWalkSpeed',description=[[Sets your own walking speed. Be careful, don't set it too high, e.g. over 100.]],parameters={type='object',properties={speed={type='number',description='The new walk speed. Set to 16 by default.',},},required={'speed',},additionalProperties=false,},strict=true,},},callback=function(r)local s=r.speed if s==nil then s=16 end p:setWalk(s)end,},{tool={type='function',['function']={name='setJumpPower',description=[[Sets your own jumping power. Be careful, don't set it too high, e.g. over 100.]],parameters={type='object',properties={power={type='number',description='The new jump power. Set to 50 by default.',},},required={'power',},additionalProperties=false,},strict=true,},},callback=function(r)local s=r.power if s==nil then s=50 end p:setJump(s)end,},},{},function(r)local s,t=l.AI.EnabledFunctions,r.tool['function'].name return table.find(s,t)~=nil end,0 for v,w in r do if t(w,v-1,r)==true then u+=1 s[u]=w end end local v=s local w=v return{aiSendMessage=q,default=w,}end a['14']=function(i)local j=h(i.Parent.Parent.include.RuntimeLib)local k=j.import(i,i.Parent.Parent,'lib','config')local l,m,n,o=k.default,k.Store,j.import(i,i.Parent.Parent,'lib','functions').getCustomService,j.import(i,i.Parent,'logger')local p,q,r,s=o.default,o.LogType,j.import(i,i.Parent,'players').default,j.import(i,i.Parent,'connection').Connection local t,u=(r:localPlayer())j.try(function()u=n'VirtualUser'end,function()p:log(q.Error,'AntiAFK','VirtualUser not found.')end)local v=function()return s.new{key=m.AntiAFK,signal=function(v)return t:onIdled(v)end,callback=function()if not u then return nil end u:CaptureController()u:ClickButton2(Vector2.new())end,check=u and l.Settings.AntiAFK,}end return{default=v}end g[=[[["out","0"],[[["classes"],[[["logger","1"]],[["store","2"]],[["messages","8"]],[["players","9"]],[["connection","10"]],[["ai","11"],[[["functions","13"]]]],[["http","12"]],[["antiafk","14"]]]],[["lib"],[[["config","3"]],[["functions","7"]]]],[["config","4"]],[["include"],[[["RuntimeLib","5"]],[["Promise","6"]]]]]]]=]return h'0'
